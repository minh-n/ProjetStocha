# Projet d'optimisation stochastique

## Introduction 

Ce projet vise Ã  proposer une solution au cÃ©lÃ¨bre problÃ¨me du voyageur de commerce : le voyageur doit passer par un ensemble de villes, avec la contrainte de ne passer quâ€™une seule fois par ville, de minimiser son temps de trajet et de retourner Ã  la ville de dÃ©part.  

Nous allons implÃ©menter un algorithme visant Ã  rÃ©soudre ce problÃ¨me de maniÃ¨re optimisÃ©e : le recuit simulÃ©, qui sera dÃ©taillÃ© par la suite, ainsi que le solveur CPLEX. Ces deux outils vont nous permettre de rÃ©soudre le problÃ¨me d'une maniÃ¨re dÃ©terministe mais Ã©galement stochastique.

## Fonctionnement

### PrÃ©-requis

Les librairies utilisÃ©es dans ce projet sont ```CPLEX, Apache Common Maths```.

Le projet a Ã©tÃ© codÃ© sous Eclipse : l'utilisateur devrait pouvoir lancer celui-ci en ouvrant le projet, puis en mettant le chemin de la librairie CPLEX dans le build path du projet.

### Interface du programme


L'application se prÃ©sente sous cette forme : 

![alt text](https://github.com/minh-n/ProjetStocha/blob/master/detatt532.PNG?raw=true)

Sur la gauche se trouvent les boutons permettant de rÃ©gler le programme. Tout dâ€™abord, lâ€™utilisateur doit choisir le fichier contenant les donnÃ©es du problÃ¨me. Ces fichiers peuvent Ãªtre de format XML : le programme ne donne accÃ¨s quâ€™Ã  ce type de fichier et pourra en rejeter certains sâ€™il ne sait pas les traiter (un message dâ€™erreur apparaÃ®tra alors, listant les diffÃ©rents types de fichiers reconnus par notre solveur). Une checkbox â€˜Get cities from a TSP fileâ€™ permet de prendre les coordonnÃ©es des villes depuis un fichier TSP de mÃªme nom que le fichier XML choisi. Cette fonctionnalitÃ© a lâ€™intÃ©rÃªt dâ€™Ã©courter considÃ©rablement les calculs dâ€™affichage pour des fichiers XML de plus de 1000 villes.

Lâ€™utilisateur devra indiquer si son jeu de donnÃ©es dÃ©crit un problÃ¨me stochastique ou un problÃ¨me dÃ©terministe.

GrÃ¢ce Ã  un menu dÃ©roulant, lâ€™utilisateur pourra choisir quel algorithme utiliser pour la rÃ©solution du problÃ¨me. Celui-ci peut Ãªtre soit CPLEX, soit le recuit simulÃ©. Il pourra Ã©galement choisir de ne pas rÃ©soudre le problÃ¨me et simplement dâ€™afficher les villes.

La partie suivante concerne les variables que lâ€™utilisateur peut paramÃ©trer sur le recuit simulÃ© et CPLEX stochastique. â€œTemperature coefficientâ€ dÃ©signe le coefficient par lequel la tempÃ©rature sera multipliÃ©e Ã  chaque palier. â€œAcceptance rateâ€ dÃ©signe le taux dâ€™acceptation minimum. â€œFailure thresholdâ€ dÃ©signe le nombre dâ€™itÃ©ration maximal par palier. â€œInitial temp. multiplierâ€ dÃ©signe le coefficient par lequel sera multipliÃ© la tempÃ©rature initiale (celle-ci Ã©tant plus Ã©levÃ©, le nombre de palier sera par consÃ©quent plus Ã©levÃ© et la solution de meilleure qualitÃ©, en thÃ©orie). â€œAlphaâ€ dÃ©signe le coefficient alpha dâ€™un problÃ¨me stochastique. 

Lâ€™utilisateur pourra alors ordonner au programme de rÃ©soudre le problÃ¨me Ã  lâ€™aide du bouton â€œLancer la rÃ©solutionâ€. Le logiciel calculera le chemin du voyageur Ã  travers la liste de villes donnÃ©es par le fichier. Les informations concernant le problÃ¨me et sa rÃ©solution seront donnÃ©s dans la partie Information.

Le solveur dessinera le chemin parcouru par le voyageur dans la partie droite de lâ€™interface. En plus du graphe, le logiciel donnera le coÃ»t associÃ© Ã  la solution, le temps de calcul demandÃ©, ainsi que le pourcentage de satisfaction de la contrainte de probabilitÃ© dans le cas dâ€™un problÃ¨me stochastique.

## Auteurs 

- Adrien LAVILLONNIÃˆRE ([@Veados](https://github.com/Veados)) : CPLEX stochastique et dÃ©terministe, modÃ©lisation prÃ©liminaire au projet
- Corentin MANSCOUR ([@neofoetus](https://github.com/neofoetus)) : Recuit simulÃ© stochastique et dÃ©terministe, modÃ©lisation prÃ©liminaire au projet
- Hien Minh NGUYEN ([@minh-n](https://github.com/minh-n)) : interface utilisateur, affichage du problÃ¨me, revue et vÃ©rification de code, Ã©criture des documents, modÃ©lisation prÃ©liminaire au projet


## Remerciements

Nous souhaitons remercier M. Abdel LISSER, notre professeur d'optimisation stochastique qui nous a guidÃ© Ã  travers ce projet. 

## Annexes

### Annexe : problÃ¨me du voyageur de commerce

Le problÃ¨me du voyageur est reformulÃ© en une fonction objectif et cinq contraintes. 

Fonction objectif : elle nous indique que le but du problÃ¨me est de minimiser la somme du coÃ»t de tous les arcs empruntÃ©s par le voyageur.

**Contrainte (1a)** : La somme de tous les coefficients xij correspondant Ã  une ville doit valoir 1, et ce pour chaque ville. Dans le parcours du voyageur, une ville i ne peut donc possÃ©der quâ€™un seul chemin se dirigeant vers une ville j. Cela signifie que lâ€™on ne sort quâ€™une seule fois de chaque ville.
**Contrainte (1b)** : Idem : on ne rentre quâ€™une seule fois dans chaque ville.
**Contrainte (1c)** : Soit S un sous ensemble de ville de cardinalitÃ© |S|. Si il y a |S| arcs ou plus reliant les villes de ce sous-ensemble, alors cela veut dire que lâ€™ensemble est un sous-tour de la solution totale, et donc que la solution nâ€™est pas acceptable.
**Contrainte (1d)** : Câ€™est la contrainte de probabilitÃ©. La solution donnÃ©e par CPLEX doit pouvoir Ãªtre de qualitÃ© proche de la solution dÃ©terministe du problÃ¨me (notÃ©e Z) au moins une certaine partie du temps (notÃ©e ğª).
**Contrainte (1e)** : assure le bon format des Ã©lÃ©ments manipulÃ©s dans le problÃ¨me 


### Annexe : l'algorithme du recuit simulÃ© 

Lâ€™algorithme du recuit simulÃ© est basÃ© sur un principe mÃ©tallurgique. Câ€™est un procÃ©dÃ© qui se dÃ©roule comme suit : un mÃ©tal est portÃ© Ã  une certaine tempÃ©rature et refroidi de maniÃ¨re contrÃ´lÃ©e. Ce cycle peut Ãªtre rÃ©pÃ©tÃ© plusieurs fois et permet de stabiliser les cristaux Ã  lâ€™intÃ©rieur de la matiÃ¨re. 

Cette technique a inspirÃ© les mathÃ©maticiens qui en ont dÃ©duit une mÃ©thode permettant de trouver le minimum ou le maximum dâ€™une fonction. 

Lâ€™algorithme du recuit simulÃ© consiste en lâ€™exploration du voisinage dâ€™une solution de la fonction objectif, en partant dâ€™un point de dÃ©part X0 et dâ€™une tempÃ©rature T0. Afin de trouver lâ€™extremum, il faut explorer le voisinage de X0 en calculant des solutions voisines Ã  celle-ci, que nous appellerons Xi. 

Si la solution Xi est meilleure que la solution initiale X0, alors on accepte cette nouvelle solution. Si au contraire la qualitÃ© de la solution est dÃ©gradÃ©e, il est quand mÃªme possible de retenir Xi. La dÃ©cision de garder ou rejeter Xi dans ce cas lÃ  est prise alÃ©atoirement grÃ¢ce Ã  la distribution de Gibbs-Boltzmann : exp(-Î”CoÃ»t/T). On tire un nombre gÃ©nÃ©rÃ© alÃ©atoirement entre 0 et 1, et si celui-ci est infÃ©rieur Ã  la probabilitÃ© de Gibbs-Boltzmann, alors on conserve Xi. Plus la tempÃ©rature est Ã©levÃ©e, plus la chance dâ€™accepter un X qui dÃ©grade la solution est Ã©levÃ©e. On doit donc observer une certaine stabilisation au fur et Ã  mesure que la tempÃ©rature descend.

On effectue ce procÃ©dÃ© un certain nombre de fois, nombre qui peut Ãªtre fixÃ© de plusieurs maniÃ¨res. Les itÃ©rations fonctionnent par cycle, par palier. A la fin de chaque palier, la tempÃ©rature est diminuÃ©e dâ€™un certain coefficient. Lâ€™algorithme sâ€™arrÃªte lorsque nous avons effectuÃ© un certain nombre de palier prÃ©dÃ©fini tout en ayant un taux dâ€™acceptation faible. Cette situation pourrait se produire lorsque la tempÃ©rature est trop basse pour quâ€™une solution coÃ»teuse soit acceptÃ©e, gÃ©nÃ©rant ainsi un taux dâ€™acceptation faible. 

